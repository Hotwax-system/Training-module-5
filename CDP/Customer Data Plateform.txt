A. Find Customer
* Use FindCustomerView to search by parameters like partyId, emailAddress, combinedName, etc.
* Support case-insensitive LIKE search for flexible matching.
* Build dynamic condition list using Moquiâ€™s EntityCondition factory.
* Output filtered partyId list.
After defining all the entities related to the party
Then we create a view of all these entity FindCustomerView in entity folder
After defining the entities and view entity 
Then we define the service for our main logic


First of all we take the reference of the execution context 
FUNCTION findCustomer(email, partyId)
    IF email IS NOT NULL THEN
        contactRecord = SELECT * FROM contact_mech WHERE info_string = email AND contact_mech_type_id = 'EMAIL_ADDRESS'
        IF contactRecord EXISTS THEN
            partyContact = SELECT party_id FROM party_contact_mech WHERE contact_mech_id = contactRecord.contact_mech_id
            IF partyContact EXISTS THEN
                RETURN partyContact.party_id
            ELSE
                RETURN "Customer not found"
            END IF
        ELSE
            RETURN "Customer not found"
        END IF
    ELSE IF partyId IS NOT NULL THEN
        partyRecord = SELECT * FROM party WHERE party_id = partyId
        IF partyRecord EXISTS THEN
            RETURN partyRecord
        ELSE
            RETURN "Customer not found"
        END IF
    ELSE
        RETURN "Invalid input: Both email and partyId are NULL"
    END IF
END FUNCTION
B. Create Customer
* Check if customer exists using find#Customer service.
* If not found:
   * Create Party (with partyTypeEnumId = PERSON)
   * Create Person with customer details
   * Create PartyRole with roleTypeEnumId = CUSTOMER
   * Create ContactMech for email
   * Link to PartyContactMech (purpose: EmailPrimary)


C. Update Customer
* Find customer by emailAddress
* Update:
   * Phone: Soft delete old contact by setting thruDate. Then create new ContactMech, TelecomNumber, and PartyContactMech.
   * Postal Address: Same flow as above using PostalPrimary.
First of all we take the reference of context


FUNCTION createCustomer(firstName, lastName, email)
    -- Step 1: Check if email already exists
    existingContact = SELECT * FROM contact_mech WHERE info_string = email AND contact_mech_type_id = 'EMAIL_ADDRESS'
    IF existingContact EXISTS THEN
        RETURN "Customer already exists"
    ELSE
        -- Step 2: Generate new party ID
        partyId = generateNewId()
        -- Step 3: Insert into party table
        INSERT INTO party (party_id, party_type_id, status_id, created_date) VALUES (partyId, 'PERSON', 'ACTIVE', CURRENT_TIMESTAMP)
        -- Step 4: Insert into person table
        INSERT INTO person (party_id, first_name, last_name) VALUES (partyId, firstName, lastName)
        -- Step 5: Assign role as CUSTOMER
        INSERT INTO party_role (party_id, role_type_id) VALUES (partyId, 'CUSTOMER')
        -- Step 6: Generate new contact_mech ID
        contactMechId = generateNewId()
        -- Step 7: Create contact_mech for email
        INSERT INTO contact_mech (contact_mech_id, contact_mech_type_id, info_string) VALUES (contactMechId, 'EMAIL_ADDRESS', email)
        -- Step 8: Link party and contact_mech
        INSERT INTO party_contact_mech (party_id, contact_mech_id, from_date) VALUES (partyId, contactMechId, CURRENT_TIMESTAMP)
        -- Step 9: Assign purpose for contact_mech
        INSERT INTO party_contact_mech_purpose (party_id, contact_mech_id, contact_mech_purpose_type_id, from_date) VALUES (partyId, contactMechId, 'EmailPrimary', CURRENT_TIMESTAMP)
        RETURN "Customer created successfully"
    END IF
END FUNCTION


FUNCTION updateCustomer(email, contactNumber, countryCode, areaCode,
                        address1, city, postalCode)


    -- Step 1: Get party_id using email
    partyRecord = SELECT party_id FROM contact_mech  JOIN party_contact_mech USING (contact_mech_id) WHERE info_string = email AND contact_mech_type_id = 'EMAIL_ADDRESS'


    IF partyRecord NOT FOUND THEN
        RETURN "Customer not found"
    END IF


    partyId = partyRecord.party_id


    -- Step 2: Update phone number (if provided)
    IF contactNumber IS NOT NULL THEN
        -- Soft delete old phone contact mechanisms
        UPDATE party_contact_mech SET thru_date = CURRENT_TIMESTAMP WHERE party_id = partyId 
AND contact_mech_id IN (
              SELECT contact_mech_id FROM contact_mech
              WHERE contact_mech_type_id = 'TELECOM_NUMBER'
          )
          AND thru_date IS NULL


        -- Insert new contact_mech for phone
        contactMechId = generateNewId()


        INSERT INTO contact_mech (contact_mech_id, contact_mech_type_id) VALUES (contactMechId, 'TELECOM_NUMBER')


        INSERT INTO telecom_number (contact_mech_id, country_code, area_code, contact_number) VALUES (contactMechId, countryCode, areaCode, contactNumber)


        INSERT INTO party_contact_mech (party_id, contact_mech_id, from_date) VALUES (partyId, contactMechId, CURRENT_TIMESTAMP)


        INSERT INTO party_contact_mech_purpose (party_id, contact_mech_id, contact_mech_purpose_type_id, from_date) VALUES (partyId, contactMechId, 'PhonePrimary', CURRENT_TIMESTAMP)
    END IF


    -- Step 3: Update postal address (if provided)
    IF address1 IS NOT NULL THEN
        -- Soft delete old address contact mechanisms
        UPDATE party_contact_mech
        SET thru_date = CURRENT_TIMESTAMP
        WHERE party_id = partyId
          AND contact_mech_id IN (
              SELECT contact_mech_id FROM contact_mech
              WHERE contact_mech_type_id = 'POSTAL_ADDRESS'
          )
          AND thru_date IS NULL


        -- Insert new contact_mech for address
        contactMechId = generateNewId()


        INSERT INTO contact_mech (contact_mech_id, contact_mech_type_id)
        VALUES (contactMechId, 'POSTAL_ADDRESS')


        INSERT INTO postal_address (contact_mech_id, address1, city, postal_code)
        VALUES (contactMechId, address1, city, postalCode)


        INSERT INTO party_contact_mech (party_id, contact_mech_id, from_date)
        VALUES (partyId, contactMechId, CURRENT_TIMESTAMP)


        INSERT INTO party_contact_mech_purpose (party_id, contact_mech_id, contact_mech_purpose_type_id, from_date)
        VALUES (partyId, contactMechId, 'PostalPrimary', CURRENT_TIMESTAMP)
    END IF


    RETURN "Customer updated"


END FUNCTION
D. Delete (Soft Delete)
* For Party: Set status to Disabled
* For ContactMech: Set thruDate to current timestamp
If user provide partyId then 
First of all we take the reference of context
FUNCTION deleteCustomer(partyId, contactMechId)
    IF partyId IS NOT NULL THEN
        -- Soft delete the party by updating its status
        UPDATE party  SET status_id = 'DISABLED' WHERE party_id = partyId
        RETURN "Customer disabled"
    END IF


    IF contactMechId IS NOT NULL THEN
        -- Soft delete the contact mechanism by setting the thru_date
        UPDATE party_contact_mech SET thru_date = CURRENT_TIMESTAMP WHERE contact_mech_id = contactMechId AND thru_date IS NULL
        RETURN "ContactMech soft deleted"
    END IF
    RETURN "No valid input provided"
END FUNCTION

